Descripción informal de autómata finito
En esta sección, estudiaremos un ejemplo extendido de un problema real, cuya solución emplea autómatas finitos que desempeñan un importante papel. Vamos a investigar protocolos que ayudan a gestionar el “dinero 32 Introducción a la teoría de autómatas, lenguajes y computación electrónico” (los archivos que un cliente puede utilizar para realizar pagos por bienes a través de Internet, y que el vendedor puede recibir con la seguridad de que el “dinero” es real). El vendedor debe estar seguro de que el archivo no ha sido falsificado y de que el cliente no se ha quedado con una copia del mismo para enviárselo más de una vez.

La cuestión de la falsificación del archivo es algo que un banco debe asegurar mediante una política criptográfica. Es decir, un tercer jugador, el banco, tiene que emitir y cifrar los archivos de “dinero”, de manera que la falsificación no constituya un problema. Sin embargo, el banco desempeña una segunda tarea también importante: tiene que mantener una base de datos de todas las transacciones válidas que se hayan realizado, de
modo que sea posible verificar al vendedor que el archivo que ha recibido representa dinero real que ha sido ingresado en su cuenta. No vamos a abordar los aspectos criptográficos del problema, ni vamos a preocuparnos de cómo el banco puede almacenar y recuperar los millones de operaciones que suponen las transacciones de
“dinero electrónico”. Es improbable que estos problemas representen impedimentos a largo plazo al concepto del dinero electrónico, y existen ejemplos de su uso a pequeña escala desde finales de los años noventa. 
Sin embargo, para poder utilizar dinero electrónico, se necesitan protocolos que permitan la manipulación del dinero en las distintas formas que los usuarios desean. Dado que los sistemas monetarios siempre invitan al fraude, tenemos que verificar la política que adoptemos independientemente de cómo se emplee el dinero. Es decir, tenemos que demostrar que las únicas cosas que pueden ocurrir son las cosas que queremos que ocurran (cosas que no permitan a un usuario poco escrupuloso robar a otros o “fabricar” su propio dinero electrónico). 
En el resto de esta sección vamos a ver un ejemplo muy simple de un (pobre) protocolo de dinero electrónico, modelado mediante un autómata finito y vamos a mostrar cómo pueden utilizarse las construcciones sobre autómatas para verificar los protocolos (o, como en este caso, para descubrir que el protocolo tiene un error).

Reglas básicas
Tenemos tres participantes: el cliente, la tienda y el banco. Para simplificar, suponemos que sólo existe un archivo de “dinero electrónico”. El cliente puede decidir transferir este archivo a la tienda, la cual lo reenviará al banco (es decir, solicita al banco que emita un nuevo archivo que refleje que el dinero pertenece a la tienda en lugar de al cliente) y suministra los bienes al cliente. Además, el cliente tiene la opción de cancelar el archivo; es decir, el cliente puede pedir al banco que devuelva el dinero a su cuenta, anulando la posibilidad de gastarlo. 
La interacción entre los tres participantes se limita por tanto a cinco sucesos:
1. El cliente decide pagar. Es decir, el cliente envía el dinero a la tienda.
2. El cliente decide cancelar el pago. El dinero se envía al banco con un mensaje que indica que el dinero se ha añadido a la cuenta bancaria del cliente.
3. La tienda suministra los bienes al cliente.
4. La tienda libra el dinero. Es decir, el dinero se envía al banco con la solicitud de que su valor se asigne a la cuenta de la tienda.
5. El banco transfiere el dinero creando un nuevo archivo de dinero electrónico cifrado y se lo envía a la tienda.